<?xml version="1.0" encoding="UTF-8"?>
<exploitDefinitions xmlns="https://www.eds.org/eds-schemas"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="https://www.eds.org/eds-schemas">
    
    <exploitDefinition
        exploitId="ed_injectionsql" 
        exploitTitle="SQL Injection">
        <description>
            A SQL injection attack consists of insertion or "injection" of a SQL query via the input data from the 
            client to the application. A successful SQL injection exploit can read sensitive data from the database, 
            modify database data (Insert/Update/Delete), execute administration operations on the database (such as 
            shutdown the DBMS), recover the content of a given file present on the DBMS file system and in some cases 
            issue commands to the operating system. SQL injection attacks are a type of injection attack, in which SQL 
            commands are injected into data-plane input in order to effect the execution of predefined SQL commands. 
            An SQL injection is a well known attack and easily prevented by simple measures.            
        </description>
        <countermeasures>            
            Parameterized statements:
            With most development platforms, parameterized statements that work with parameters can be used (sometimes 
            called placeholders or bind variables) instead of embedding user input in the statement. A placeholder can 
            only store a value of the given type and not an arbitrary SQL fragment. Hence the SQL injection would simply 
            be treated as a strange (and probably invalid) parameter value.
            
            Enforcement at the coding level:
            Using object-relational mapping libraries avoids the need to write SQL code. The ORM library in effect will 
            generate parameterized SQL statements from object-oriented code.
            
            Escaping:
            A straightforward, though error-prone way to prevent injections is to escape characters that have a special 
            meaning in SQL. The manual for an SQL DBMS explains which characters have a special meaning, which allows 
            creating a comprehensive blacklist of characters that need translation. For instance, every occurrence of a 
            single quote (') in a parameter must be replaced by two single quotes ('') to form a valid SQL string literal.            
            Routinely passing escaped strings to SQL is error prone because it is easy to forget to escape a given string. 
            Creating a transparent layer to secure the input can reduce this error-proneness, if not entirely eliminate it.
            
            Pattern check:
            Integer, float or boolean, string parameters can be checked if their value is valid representation for the 
            given type. Strings that must follow some strict pattern (date, UUID, alphanumeric only, etc.) can be checked 
            if they match this pattern.
            
            Database permissions:
            Limiting the permissions on the database login used by the web application to only what is needed may help 
            reduce the effectiveness of any SQL injection attacks that exploit any bugs in the web application.
        </countermeasures>
    </exploitDefinition>
    
    <exploitDefinition 
        exploitId="ed_injectionxml" 
        exploitTitle="XML Injection">
        <description>
            XML injection vulnerabilities arise when user input is inserted into a server-side XML document or 
            SOAP message in an unsafe way. It may be possible to use XML metacharacters to modify the structure of the 
            resulting XML. Depending on the function in which the XML is used, it may be possible to interfere with the 
            application's logic, to perform unauthorized actions or access sensitive data.            
            This kind of vulnerability can be difficult to detect and exploit remotely; you should review the application's 
            response, and the purpose that the relevant input performs within the application's functionality, to determine 
            whether it is indeed vulnerable.
        </description>
        <countermeasures>
            Escaping:
            A straightforward, though error-prone way to prevent injections is to escape characters that have a special 
            meaning in SQL. The manual for an SQL DBMS explains which characters have a special meaning, which allows 
            creating a comprehensive blacklist of characters that need translation. For instance, every occurrence of a 
            single quote (') in a parameter must be replaced by two single quotes ('') to form a valid SQL string literal.            
            Routinely passing escaped strings to SQL is error prone because it is easy to forget to escape a given string. 
            Creating a transparent layer to secure the input can reduce this error-proneness, if not entirely eliminate it.
            
            Pattern check:
            Integer, float or boolean, string parameters can be checked if their value is valid representation for the 
            given type. Strings that must follow some strict pattern (date, UUID, alphanumeric only, etc.) can be checked 
            if they match this pattern.        
        </countermeasures>
    </exploitDefinition>
    
    <exploitDefinition 
        exploitId="ed_xss" 
        exploitTitle="Cross-Site Scripting">
        <description>
            The weakness occurs when software does not perform or incorrectly performs neutralization of input data before 
            displaying it in user's browser. As a result, an attacker is able to inject and execute arbitrary HTML and 
            script code in user's browser in context of a vulnerable website. Based on weakness conditions it is common 
            to divide cross-site scripting errors into 3 main types: reflected XSS, stored XSS and DOM-based XSS.
            
            1 Reflected XSS (Non-persistent XSS)            
            This type describes an error when application reads input data from the HTTP request and reflects it back in 
            HTTP response. The malicious content is never stored in the application and can be viewed only when user follows 
            a specially crafted link.
            
            2 Stored XSS (persistent XSS)            
            This type describes an error when application reads input data from the HTTP request and stores it in database, 
            logs, cached pages, etc. Malicious code can be later executed in user's browser when user visits a vulnerable 
            page.
            
            3 DOM-based XSS            
            This type describes an error within the DOM model of user's browser. That means that injection occurs inside 
            the client script that accepts and return back data from user's browser.
        </description>
        <countermeasures>
            Perform sanitation of input data before inserting it into the page content:  
            Any character that might be treated by the web browser as HTML content should be sanitized. These are the 
            characters that should be escaped when handling untrusted input: "lower than" = "&lt;", "greather than" = "&gt;",
            "double quotes" = "&quot;", "single quotes" = "&#x27;", "ampersand" = "&amp;", "slash" = "&#x2F;". Developers 
            should use URL-encoding on input inserted into URL tags. When untrusted input is inserted into script or event 
            all quotation symbols and backslashes should be escaped. All properly escaped data within javascript code should 
            be included into quotes. When usage of untrusted input as strings or names within scripts or events is crucial 
            for application design, this input should be sanitized and contain strictly letters and numbers.
            
            Use native API and additional software whenever possible:
            PHP has native API that can help protect application from XSS attacks. Developers can use htmlspecialchars() 
            or htmlentities() functions to deal with untrusted input. Microsoft web protection library is also a great set 
            of .NET assemblies that should be used when developing applications in .NET.
            
            Always use preset character encoding of the displayed page:
            Never rely on browser auto-select encoding functionality. An attacker might be able to bypass sanitation checks 
            and perform successful XSS attacks if page encoding is not preset and user's browser is configured to use 
            auto-select encoding.
        </countermeasures>
    </exploitDefinition>
    
    <exploitDefinition 
        exploitId="ed_csrf" 
        exploitTitle="Cross-Site Request Forgey">
        <description>
            Cross-site request forgery (CSRF) is a weakness within a web application which is caused by insufficient or 
            absent verification of the HTTP request origin. Webservers are usually designed to accept all requests and 
            respond to them. If a client sends several HTTP requests within one or several sessions, it is impossible for 
            a webserver to know whether all the requests were intentional, and they are treated as such. An attacker might 
            be able to trick a user into visiting a specially crafted webpage and forge request to the vulnerable 
            application from client's browser.
        </description>
        <countermeasures>
            Ensure that your application does not have cross-site scripting vulnerabilities:
            A cross-site scripting vulnerability can be used by an attacker to steal the security token and use it in an 
            attack against the application. The injected script can interact with page elements, read existing tokens and 
            automatically submit the request.
            
            Generate a unique token for each entity:
            It’s strongly recommended to generate a unique time based-identifier for each entity. It should consist of a 
            unique randomly generated string, which can be used within specific timeframe and limited number of times 
            (preferably just once per entity). This approach will limit possibility for a replay attack, if the security 
            token is somehow intercepted. This token should not be based on account information, provided by the user, 
            and should be hard to guess in case of a brute-force attack, e.g. consist of at least 10-20 characters.
            
            Use CAPTCHA when possible:
            Although there is a lot of different techniques and software to guess the CAPTCHA word, it still can be used 
            as an additional protection layer against CSRF attacks.
            
            Identify dangerous operations and always demand confirmation of dangerous actions:
            Developers should identify dangerous operations and treat them with caution. For example, when changing 
            account password always demand from user to provide his/her old password; if application allows to drop 
            database, confirm this action by demanding an extra password or CAPTCHA for that matter.
            
            Use protection frameworks:
            If you are unable to develop proper CSRF protection mechanism or are not sure of its security level, you can 
            also implement existing solutions, such as: OWASP CSRF Guard (For Java), PHP CSRF Guard, Net CSRF Guard.
        </countermeasures>
    </exploitDefinition>
    
    <exploitDefinition 
        exploitId="ed_sniffing" 
        exploitTitle="Sniffing">
        <description>
            Sniffing application traffic simply means that the attacker is able to view network traffic and will try to 
            steal credentials, confidential information, or other sensitive data.            
            Anyone with physical access to the network, whether it is switched or via a hub, is likely able to sniff 
            the traffic. (See dsniff and arpspoof tools). Also, anyone with access to intermediate routers, firewalls, 
            proxies, servers, or other networking gear may be able to see the traffic as well.
        </description>
        <countermeasures>
            Encrypt data:
            Considering the threats you plan to protect this data from (e.g., insider attack, external user), make sure 
            you encrypt all sensitive data at rest and in transit in a manner that defends against these threats.
            
            Discard unnecessary sensitive data:
            Don’t store sensitive data unnecessarily. Discard it as soon as possible. Data you don’t retain can’t be stolen
            
            Establish strong encrypting mechanisms:
            Ensure strong standard algorithms and strong keys are used, and proper key management is in place. Consider 
            using FIPS 140 validated cryptographic modules.
            
            Disable autocomplete:
            Disable autocomplete on forms requesting sensitive data and disable caching for pages that contain sensitive data
        </countermeasures>
    </exploitDefinition>
    
    <exploitDefinition 
        exploitId="ed_sessionhijack" 
        exploitTitle="Session Hijack">
        <description>      
            Session hijacking is a method of taking over a Web user session by surreptitiously obtaining the session ID 
            and masquerading as the authorized user. Once the user’s session ID has been accessed (through session 
            prediction), the attacker can masquerade as that user and do anything the user is authorized to do on the 
            network.
            Session hijacking is the exploitation of a valid computer session—sometimes also called a session key—to 
            gain unauthorized access to information or services in a computer system. In particular, it is used to refer 
            to the theft of a magic cookie used to authenticate a user to a remote server. It has particular relevance 
            to web developers, as the HTTP cookies used to maintain a session on many web sites can be easily stolen by 
            an attacker using an intermediary computer or with access to the saved cookies on the victim’s computer.
        </description>
        <countermeasures>
            Long session key:
            Use of a long random number or string as the session key. This reduces the risk that an attacker could simply 
            guess a valid session key through trial and error or brute force attacks.
            
            Regenerating the session id:
            Regenerating the session id after a successful login prevents session fixation because the attacker does not 
            know the session id of the user after s/he has logged in.
            
            Secondary checks:
            Some services make secondary checks against the identity of the user. For example, a web server could check 
            with each request made that the IP address of the user matched the one last used during that session. This does 
            not prevent attacks by somebody who shares the same IP address, however, and could be frustrating for users 
            whose IP address is liable to change during a browsing session.
            
            Change cookie value:
            Alternatively, some services will change the value of the cookie with each and every request. This 
            dramatically reduces the window in which an attacker can operate and makes it easy to identify whether an 
            attack has taken place, but can cause other technical problems (for example, two legitimate, closely timed 
            requests from the same client can lead to a token check error on the server).
        </countermeasures>
    </exploitDefinition>
    
    <exploitDefinition 
        exploitId="ed_elevationprivilege" 
        exploitTitle="Elevation of Privilege">
        <description>
            Consider the types of authorized users of your system. Some of those users are restricted to certain functions 
            and data. Also, unauthenticated users are probably not allowed to access all (or some) of functionality and data.            
            Attackers, who are authorized users, simply change a parameter value to another resource they aren’t authorized 
            for. 
            For data, applications and APIs frequently use the actual name or key of an object when generating web pages. 
            For functions, URLs and function names are frequently easy to guess. Applications and APIs don’t always verify 
            the user is authorized for the target resource. As atacker gets privilege he is not supposed to, access control 
            flaw results in elevation of privilege. Testers can easily manipulate parameters to detect such flaws. Code 
            analysis quickly shows whether authorization is correct.
        </description>
        <countermeasures>
            Check access:
            Each use of a direct reference from an untrusted source must include an access control check to ensure the 
            user is authorized for the requested resource.
            
            Use per user or session indirect object references:
            This coding pattern prevents attackers from directly targeting unauthorized resources. For example, instead 
            of using the resource’s database key, a drop down list of six resources authorized for the current user 
            could use the numbers 1 to 6 to indicate which value the user selected. OWASP’s ESAPI includes both sequential 
            and random access reference maps that developers can use to eliminate direct object references.
            
            Automated verification:
            Leverage automation to verify proper authorization deployment. This is often custom.
        </countermeasures>
    </exploitDefinition>
    
</exploitDefinitions>